<!--主要参考了菜鸟教程-->
# 1 数据类型
## 1.1 基本数据类型
**它们是算术类型**
> - int 整型
> - char 字符型
> - float 浮点型
> - double 双精度浮点型

## 1.2 枚举类型
**也是算术类型**
> 只能赋予其一定的离散整数值的变量

## 1.3 void 类型
**表明没有值的数据类型**

## 1.4 派生类型
> - 数组类型
> - 指针类型
> - 结构体类型


<font color=red>各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。
以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：</font>
![](Images/2023-06-24-23-32-23.png)

## 1.5 强制类型转换

> - **隐式类型转换**：隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。**它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。**
> - **显式类型转换**：**显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值**。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。
```c
/*隐式类型转换实例*/
int i = 10;
float f = 3.14;
double d = i + f; // 隐式将int类型转换为double类型

/*显式类型转换实例*/
double d = 3.14159;
int i = (int)d; // 显式将double类型转换为int类型
```


# 2 C常量

## 2.1 整数常量

> 整数常量可以是十进制、八进制或十六进制的常量。**前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。**
> 整数常量也可以带一个后缀，<font color=red>后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。但是不能重复。</font>

```c
212         /* 合法的 */
215u        /* 合法的 */
0xFeeL      /* 合法的 */
078         /* 非法的：8 不是八进制的数字 */
032UU       /* 非法的：不能重复后缀 */

/*下面是各种类型的整数常量的实例*/
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
```

## 2.2 浮点常量

> - 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
> - 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

```c
/*浮点常量的例子*/
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
```

## 2.3 字符常量和字符串常量

> - 字符常量是记录在在单引号中的
> 字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）.在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。
> - 字符串常量是记录在双引号中的

## 2.4 定义常量

> 1. **使用 #define 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。**
> 2. **使用 const 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。**

```c
/*把常量定义为大写字母形式，是一个很好的编程习惯*/

/*define 定义常量*/

#define 常量名 常量值
#define PI 3.14159

/*const 定义常量*/
const 数据类型 常量名 = 常量值;
/*下面的代码定义了一个名为MAX_VALUE的常量：*/
const int MAX_VALUE = 100;
```
### 2.4.1 #define 与 const 区别

> **#define 与 const 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用 const 关键字来定义常量，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。#define 预处理指令和 const 关键字在定义常量时有一些区别：**
> - 替换机制：**#define 是进行简单的文本替换，而 const 是声明一个具有类型的常量。**#define 定义的常量在编译时会被直接替换为其对应的值，而 const 定义的常量在程序运行时会分配内存，并且具有类型信息。
> - 类型检查：**#define 不进行类型检查，因为它只是进行简单的文本替换。而 const 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。**
> - 作用域：**#define 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 const 定义的常量具有块级作用域，只在其定义所在的作用域内有效。**
> - 调试和符号表：**使用 #define 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 const 定义的常量会在符号表中有相应的条目，有助于调试和可读性。**
>
> **下面的表述可以更清晰地了解二者的区别**
> ![](Images/2023-06-25-00-22-25.png)

# 3 存储类

## 3.1 auto 存储类
> auto 存储类是所有局部变量默认的存储类。定义在函数中的变量默认为 auto 存储类，这意味着它们在函数开始时被创建，在函数结束时被销毁。

## 3.2 register 存储类

在C语言中，`register`是一种存储类（storage class），用于向编译器提示将变量存储在寄存器中，以便提高访问速度。然而，需要注意的是，`register`只是一种建议，编译器可以选择忽略它。

以下是有关`register`存储类的详细说明：

1. 声明：可以使用`register`关键字在变量声明时指定该变量的存储类。例如：
```c
register int x;
```
这将提示编译器将变量`x`存储在寄存器中。

2. 可寄存器的类型：通常，只有较小的整数类型（如`int`、`char`）或指针类型的变量才能存储在寄存器中。对于较大的数据类型（如结构体或数组），编译器通常会忽略`register`关键字。

3. 可寄存器的数量：由于寄存器数量有限，所以无法保证所有使用`register`关键字声明的变量都会被存储在寄存器中。编译器将根据需求和可用的寄存器来决定哪些变量应存储在寄存器中。

4. 地址访问：由于寄存器是在CPU内部存储数据的临时位置，无法直接访问寄存器的地址。因此，<font color=red>不能使用指针或取地址运算符（`&`）来获取寄存器中变量的地址。</font>

5. 限制和建议：尽管使用`register`关键字可以提高访问速度，但在现代的编译器中，它的作用已经减弱。编译器通常能够自动识别并进行优化，因此手动使用`register`并不能保证性能的提升。在大多数情况下，编译器能够更好地优化代码，因此不建议过度使用`register`关键字。

<font color=red>需要注意的是，C99标准中已经将`register`关键字废弃为保留字，因此在新的代码中，`register`关键字已经失去了原有的含义。现代编译器往往会忽略`register`关键字，并根据需要自动进行寄存器分配。</font>


# 4 函数

## 4.1 static 和 extern 函数

- `static`函数只能在本文件中使用，不能在外部使用
- 在定义文件的时候，如果加上`extern`则表示函数可以在外部使用，如果不加，则<font color=red>可以被外部引用</font>

## 4.2 inline函数(内联函数)

内联函数是指用`inline`关键字修饰的函数。在类内定义的函数被默认成内联函数。内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。

内联扩展是用来消除函数调用时的时间开销。它通常用于频繁执行的函数，对于小内存空间的函数非常受益。

使用内联函数的时候要注意：

- 递归函数不能定义为内联函数
- 内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。
- 内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。
- 对内联函数不能进行异常的接口声明。

## 4.3 main 函数

`int main( int argc, char *argv[] )`
上面的代码中 main 函数带了参数。

但是有时又会看见main函数没有参数，如下：

`int main()`
那么 main 函数到底有没有参数，有没有参数会不会有什么影响？

main 函数其实与我们写的函数没有什么区别，它也会有自己的参数。

**argc 和 argv 是 main 函数的形式参数。**

这两个形式参数的类型是系统规定的。如果 main 函数要带参数，就是这两个类型的参数；否则main函数就没有参数。

变量名称argc和argv是常规的名称，当然也可以换成其他名称。在传入参数后main函数收到参数后就会做自己的事。那么，实际参数是如何传递给main函数的argc和argv的呢？我们知道，**C程序在编译和链接后，都生成一个exe文件，执行该exe文件时，可以直接执行；也可以在命令行下带参数执行，命令行执行的形式为：可执行文件名称 参数1 参数2 ... ... 参数n。可执行文件名称和参数、参数之间均使用空格隔开。**

如果按照这种方法执行，命令行字符串将作为实际参数传递给main函数。具体为：

 (1) 可执行文件名称和所有参数的个数之和传递给 argc；
 (2) 可执行文件名称（包括路径名称）作为一个字符串，首地址被赋给 argv[0]，参数1也作为一个字符串，首地址被赋给 argv[1]，... ...依次类推。

# 5 数组

## 5.1 数组的大小、地址和初始化

### 5.1.1 数组的初始化

对于数组的初始化需要注意以下几点：

1.  可以只给部分元素赋值，当 { } 中值的个数少于元素个数时，只给前面部分元素赋值。例如：

    `int a[10]={12, 19, 22 , 993, 344};`
    表示只给 a[0]~a[4] 5 个元素赋值，而后面 5 个元素自动初始化为 0。

    <font color=red>当赋值的元素少于数组总体元素的时候，不同类型剩余的元素自动初始化值说明如下：

    对于 short、int、long，就是整数 0；
    对于 char，就是字符 '\0'；
    对于 float、double，就是小数 0.0。
    我们可以通过下面的形式将数组的所有元素初始化为 0：

    `int nums[10] = {0};`
    `char str[10] = {0};`
    `float scores[10] = {0.0};`
    由于剩余的元素会自动初始化为 0，所以只需要给第 0 个元素赋值为 0 即可。</font>

2. 只能给元素逐个赋值，不能给数组整体赋值。例如给 10 个元素全部赋值为 1，只能写作：

    `int a[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};`
    而不能写作：

   `int a[10] = 1;`

### 5.1.2 指针与数组名的区别

指针：也是一个变量，存储的数据是地址。

数组名：代表的是该数组最开始的一个元素的地址。

`int a[10];`
`int *p;`
`p = &a[0] // 可以写成 p = a;`
对数组元素 a[i]的引用也可以写成*(a+i)这种形式。
赋值语句  p=&a[0] 也可以写成下列形式: p=a。
p 是个指针，p[i]与*(p+i)是等价的。
`区别：指针是一个变量，可以进行数值运算。数组名不是变量，不可以进行数值运算。`

## 5.2 动态数组

动态数组
动态数组是在运行时通过动态内存分配函数（如 malloc 和 calloc）手动分配内存的数组。

动态数组特点如下：

内存分配：动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。需要使用 **malloc、calloc** 等函数来申请内存，并使用 free 函数来释放内存。
大小可变：动态数组的大小在运行时可以根据需要进行调整。可以使**用 realloc 函数来重新分配内存，并改变数组的大小**。
生命周期：动态数组的生命周期由程序员控制。需要在使用完数组后手动释放内存，以避免内存泄漏。
- 动态数组的声明、内存分配和释放实例：
```c
int size = 5;
int *dynamicArray = (int *)malloc(size * sizeof
(int)); // 动态数组内存分配
// 使用动态数组
free(dynamicArray); // 动态数组内存释放
```

- 动态分配的数组，可以在动态分配内存时保存数组长度，并在需要时使用该长度，例如：

```c
int size = 5; // 数组长度
int *array = malloc(size * sizeof(int));

// 使用数组

free(array); // 释放内存
```
以上代码我们使用 malloc 函数动态分配了一个整型数组，并将长度保存在变量 size 中。然后可以根据需要使用这个长度进行操作，在使用完数组后，使用 free 函数释放内存。

注意：动态数组的使用需要注意内存管理的问题，确保在不再需要使用数组时释放内存，避免内存泄漏和访问无效的内存位置。

### 5.2.1 malloc 和 calloc 的区别

`malloc` 和 `calloc` 都是在 C 语言中用于动态分配内存的函数，它们之间有以下区别：

1. 参数不同：`malloc` 函数只接受一个参数，用于指定要分配的字节数；而 `calloc` 函数则接受两个参数，第一个参数用于指定要分配的元素个数，第二个参数用于指定每个元素的大小。

2. 初始化值不同：`malloc` 分配的内存块中的内容是未初始化的，可能包含垃圾值，需要手动进行初始化；而 `calloc` 分配的内存块会被自动初始化为 0，每个字节都被设置为 0。

3. 返回值和用途：`malloc` 返回一个指向分配内存块的指针，可以根据需要进行类型转换；而 `calloc` 返回一个指向分配内存块的指针，通常用于分配数组或需要初始化为 0 的内存块。

4. 性能：由于 `calloc` 在分配内存时会自动进行初始化，可能会比 `malloc` 略微慢一些，因为它需要额外的操作来清零分配的内存块。然而，这种差异对于大多数情况来说是微不足道的。

选择使用 `malloc` 还是 `calloc` 取决于具体的需求。如果你需要分配一个数组或需要确保分配的内存块是初始化为 0 的，那么使用 `calloc` 是一个更好的选择。如果你只需要分配一块内存，而不关心其初始值，那么使用 `malloc` 即可。

